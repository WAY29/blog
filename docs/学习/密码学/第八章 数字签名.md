# 数字签名
## RSA数字签名
1. 参数产生
①选择两个满足需要的大素数p和q，计算n=p×q, φ(n)= (p-1)×(q-1)，其中φ(n)是n的欧拉函数值。
    ②选一个整数e, 满足1<e<φ(n)，且gcd(φ(n),e)=1。通过d×e≡1modφ(n)，计算出d。
③以{e,n}为公开密钥，{d,n}为秘密密钥。
2. 签名过程
假设签名者为Bob，则只有Bob知道秘密密钥{d, n}。
设需要签名的消息为m，则签名者Bob通过如下计算对m签名：s≡md mod n
（m, s）为对消息m的签名。Bob在公共媒体上宣称他发布了消息m，同时把对m的签名s置于消息后用于公众验证签名。
3. 验证过程
公众在看到消息m和对其签名s后，利用Bob的公开验证密钥{e, n}对消息进行验证。公众计算：m≡se mod n是否成立，若成立，则Bob的签名有效。公众认为消息m的确是Bob所发布，且消息内容没有被篡改。也就是说，公众可以容易鉴别发布人发布的消息的完整性。

## RSA签名算法缺陷
假设攻击者Eve想得到签名者对消息M的签名，则攻击者Eve可以构造消息M1和M2，使M=M1*M2。然后把消息M1和M2分别发送给签名者Bob进行签名。
（1）设Bob对消息M1的签名为S1，即S1≡M1d mod n；
（2）设Bob对消息M2的签名为S2，即S2≡M2d mod n；
在得到Bob的两次对消息的签名后，则攻击者Eve很容易构造消息M的签名S，S= Md=（M1*M2)dmodn≡S2*S1。
虽然说在已知M的情况下，M1、M2往往只是一个数值，一般来说是没有意义的。但进行签名的往往是一台机器，不会对消息有无意义进行鉴别，故导致了算法的不安全
## RSA改进签名
![](https://gitee.com/guuest/images/raw/master/img/20210617205005.png)
